import hmac
import logging
import uuid
from hashlib import sha256

from django.core.exceptions import ObjectDoesNotExist, PermissionDenied
from rest_framework.permissions import BasePermission

from api.models import FlouciApp
from partners.models import LinkedAccount
from settings.settings import CASH_IO_VERIFICATION_TOKEN
from utils.jwt_helpers import verify_backend_token

logger = logging.getLogger(__name__)


class IsFlouciAuthenticated(BasePermission):
    """
    has a valid jwt generated by backend
    """

    def has_permission(self, request, view):
        token = request.META.get("HTTP_AUTHORIZATION")
        if not token or not token.startswith("Bearer "):
            return False
        token = token.split(" ")[1]  # Extract the token part after "Bearer "
        if token == "":
            return False
        verified, data = verify_backend_token(token)
        if not verified:
            return False
        for key, value in data.items():
            setattr(request, key, value)
        return True


class HasValidAppCredentials(BasePermission):
    """
    Validates the app credentials and returns the application to the view
    """

    def has_permission(self, request, view):
        # Try to get from headers first
        app_token = request.headers.get("App-Token")
        app_secret = request.headers.get("App-Secret")
        # If not found in headers, check request data
        if not app_token or not app_secret:
            app_token = request.data.get("app_token") or request.query_params.get("app_token")
            app_secret = request.data.get("app_secret") or request.query_params.get("app_secret")
        if not app_token or not app_secret:
            return False
        try:
            uuid.UUID(app_token)
            uuid.UUID(app_secret)
        except ValueError:
            return False
        try:
            application = FlouciApp.objects.get(public_token=app_token, private_token=app_secret, active=True)
        except ObjectDoesNotExist:
            return False
        request.application = application
        return True


class HasValidAppCredentialsV2(BasePermission):
    """
    Validates the app credentials and returns the application to the view
    """

    def has_permission(self, request, view):
        token = request.META.get("HTTP_AUTHORIZATION")
        if not token or not token.startswith("Bearer "):
            return False
        token = token.split(" ")[1]  # Extract the token part after "Bearer "
        public_token = token.split(":")[0]
        private_token = token.split(":")[1]
        try:
            uuid.UUID(public_token)
            uuid.UUID(private_token)
        except ValueError:
            return False
        try:
            application = FlouciApp.objects.get(public_token=public_token, private_token=private_token, active=True)
        except ObjectDoesNotExist:
            return False
        request.application = application
        return True


class HasValidPartnerAppCredentials(BasePermission):
    """
    Validates the app credentials and returns the application to the view
    """

    def has_permission(self, request, view):
        token = request.META.get("HTTP_AUTHORIZATION")

        if not token or not token.startswith("Bearer "):
            return False
        token = token.split(" ")[1]  # Extract the token part after "Bearer "
        public_token = token.split(":")[0]
        private_token = token.split(":")[1]
        try:
            uuid.UUID(public_token)
            uuid.UUID(private_token)
        except ValueError:
            return False
        try:
            application = FlouciApp.objects.get(
                public_token=public_token, private_token=private_token, active=True, has_partner_access=True
            )
        except ObjectDoesNotExist:
            return False
        request.application = application
        return True


class IsValidPartnerUser(BasePermission):
    def has_permission(self, request, view):
        if request.method == "GET":
            application_tracking_id = request.query_params.get("tracking_id")
            phone_number = request.query_params.get("phone_number")
        else:
            application_tracking_id = request.data.get("tracking_id")
            phone_number = request.data.get("phone_number")

        merchant_id = request.application.merchant_id
        try:
            account = LinkedAccount.objects.get(
                phone_number=phone_number, partner_tracking_id=application_tracking_id, merchant_id=merchant_id
            )
            request.account = account
            return True
        except ObjectDoesNotExist:
            raise PermissionDenied({"success": False, "message": "Invalid credentials"})


class IsPartnerAuthenticated(BasePermission):
    """
    Allows access to only authenticated Flouci users with their personal or business account,
    to use in API endpoint, just add this line
    permission_classes = (IsPartnerAuthenticated, )
    in the beginning of the class
    """

    def has_permission(self, request, view):
        token = request.META.get("HTTP_AUTHORIZATION")
        if not token or not token.startswith("Bearer "):
            return False
        token = token.split(" ")[1]  # Extract the token part after "Bearer "
        verified, data = verify_backend_token(token)
        if not verified:
            return False
        try:
            linked_account = LinkedAccount.objects.get(
                partner_tracking_id=data.get("partner_tracking_id"), merchant_id=data.get("mid")
            )
            request.account = linked_account
            request.partner_tracking_id = data.get("partner_tracking_id")
            request.merchant_id = data.get("mid")
            return True
        except ObjectDoesNotExist:
            return False


def signed_request_is_valid(request, secret):
    """Validate signed requests."""
    api_signature = request.META.get("HTTP_SIGNATURE")
    if api_signature:
        request_check_field = request.data.get("id")  # fetch check_field in request.data
        if request_check_field is None:
            return False
        signature = generate_request_signature(secret, request.method, request.path, request_check_field)
        return signature == api_signature
    else:
        return False


def generate_request_signature(secret, request_method, request_path, request_check_field):
    params = [secret, request_method, request_path, request_check_field]
    formatted_data = "-".join(params)
    formatted_data = formatted_data.encode("utf-8")
    return hmac.new(secret.encode("utf-8"), msg=formatted_data, digestmod=sha256).hexdigest()


class HasValidDataApiSignature(BasePermission):
    def has_permission(self, request, view):
        # For most webhook catchers we use this
        if signed_request_is_valid(request, CASH_IO_VERIFICATION_TOKEN):
            return True
        logger.warning("A request with wrong api signature is calling data api webhook catcher")
        return False
